\section{Future Work}
\label{sec:futurework}
\paragraph{}
We envision Tracer to be capable of supporting efficient memory management libraries which would be wrapped around it. Tracer provides the application developer with accurate information about the application's memory access pattern. This information could be used for offline and online memory management models.

\subsection{Online Memory Management Model}
The online memory model design would involve a dynamic memory manager (similar to a JAVA runtime) which would move and pack objects with similar access patterns together in the same pages. The dynamic memory management system would be built on top of Tracer. The caching system used in SSDAlloc is able to change the location of objects owing to its {\emph{"Object Per Page Model"}}. However, such a design increases the TLB pressure. In keeping with our model of simplicity in implementation and a focus on user space solutions, we would prefer to take a different path. However, moving objects in the virtual memory requires updating any pointers to those objects, and as such would require backlinks unless application semantics were significantly restricted. As such, we expect that the dynamic memory management implementation would make user of the programmer's cooperation, in a manner akin to cooperative multithreading. Here, applications would indicate when they were in a state that would guarantee that object pointers are currently not being accessed. This would activate the memory management system, freezing the application until suitable objects were relocated.

\subsection{Offline Memory Management Model}
In the offline memory management model, the application developer can run benchmarks on an application design, from which Tracer would provide fine grained memory access information. The developer could then enhance the application's performance by adequately restructuring the application's memory usage (for example, by allocating frequently accessed objects together).

\paragraph{Improvement in interceptor's capabilities}
Enhancements could be made to the parsing abilities of Tracer's interceptor. At the moment, the subset of C which the parser supports focuses on structs and simple C syntax. In order to support more idiomatic C, richer features would have to be added. Primary amongst these is support for arrays, which is likely to require some careful implementation. Given the current header-based counting used in Tracer, there are several considerations for array suppport. The header can be added per-array (perhaps for primitive C types), or per-object. To keep per-object tracking may require modifications to the instrumented code, such as adding the counter as a struct member, rather than as a header. For arrays of pointers, the counts would likely be unnecessary.
