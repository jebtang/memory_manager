\section{Introduction} 
\label{sec:intro}
\paragraph{}
Memory tracing is a difficult problem to resolve since most of the accesses to memory occur through hardware (in traditional C based applications). Software based techniques such as those used by {\emph{Valgrind's memcheck \cite{Valgrind}} and {\emph{gdb's ptrace}} \cite{gdb} rely on memory protection mechanisms which introduce heavy overheads and therefore cannot be effectively used with high end applications. This work presents the design, implementation and evaluation of Tracer, a code based instrumentation system coupled with memory monitoring techniques which enables applications to transparently obtain application's memory footprints with low overhead. 

\paragraph{Design philosophy}
Tracer provides APIs for efficient tracking of object-level memory accesses. Previous works on object caching makes use of memory protection mechanisms, resulting in page faults on object accesses and high virtual memory space utilization. We aim to minimize overheads while providing useful information to the application programmer. This information can assist application developers in enhancing application performance by compact placement of "hot" objects. This would reduce access latencies and result in better memory usage. Overall, the philosophy underlying the design of Tracer's architecture can be enumerated as follows:
\begin{enumerate}
\item The interception mechanism must be completely transparent to the application developer.
\item The interceptor and the memory monitoring libraries must be easily pluggable into a standard C application.
\item The overall overheads must be reasonable compared to the performance of a vanilla C application.
\item The design of the solution must be system independent (independent of POSIX system calls such as protection mechanisms, underlying hardware).
\end{enumerate}

\paragraph{}
This work presents the design of Tracer. Tracer provides a C pre-processing tool called the {\emph{interceptor}} and a set of APIs (bundled with the standard GNU C library) for monitoring and providing the overall memory access footprint at an object level granularity to C application developers. Our system design achieves all the above lying objectives (outlined {\emph{design philosophy}}. The interceptor uses preprocessing through standard code parsing techniques and injects {\emph{"memory access"}} calls into the C program, thus making the design transparent to the application developer and easily pluggable with standard C applications. The monitoring library is implemented as a part of the standard GNU C library.  The solution does not depend on hardware or require additional hardware and is therefore independent of the platform used. Our implementation on binary tree micro benchmarks report an overhead between roughly $20\%$ and $40\%$ for create and read workloads. We therefore believe that Tracer is a useful and efficient software solution which could augment application development by providing better memory monitoring techniques.


\paragraph{}
The paper is organized as follows: Section \ref{sec:motivation} outlines the motivation underlying our work.  Section \ref{sec:design} describes the design of Tracer. Section \ref{sec:eval} describes the microbenchmark study and discussion of results. Section \ref{sec:futurework} provides insight into useful ideas which could improve the design of Tracer. Section \ref{sec:related} discusses some of the previous pieces of work related to Tracer's design. Section \ref{sec:conclusion} provides a summary of our work.


